import DocCard from '@site/src/components/DocCard';

# Dependency Management & Imports

Windmill's strength lies in its ability to run scripts without having to manage a package.json directly. This is achieved by automatically parsing the imports and resolving the dependencies.

When a script is deployed through its UI, Windmill generates a lockfile to ensure that the same version of a script is always executed with the same versions of its dependencies. If no version is specified, the latest version is used. Windmill's workers cache dependencies to ensure fast performance without the need to pre-package dependencies - most jobs take under 100ms end-to-end.

On the [enterprise edition](/pricing), Windmill's caches can be configured to sync their cache with a central S3 repository to distribute the cache across multiple workers as soon as a new dependency is used for the first time.

## Imports in TypeScript

See our dedicated page on [Dependencies in TypeScript](../14_dependencies_in_typescript/index.mdx).

<div className="grid grid-cols-2 gap-6 mb-4">
	<DocCard
		title="Dependencies in TypeScript"
		description="How to manage dependencies in TypeScript scripts."
		href="/docs/advanced/dependencies_in_typescript"
	/>
</div>

## Imports in Python

For Python, the imports are automatically parsed on saving of the script and a list of imports is generated. A dependency job is then
spawned to associate that list of PyPi packages with a lockfile, which will lock
the versions. This ensures that the same version of a Python script is always
executed with the same versions of its dependencies. It also avoids the hassle
of having to maintain a separate requirements file.

We use a simple heuristics to infer the package name: the import root name must be the package name. We also maintain a list of exceptions.
You can make a PR to add your dependency to the list of exceptions [here](https://github.com/windmill-labs/windmill/blob/baac93f40140ee37548a273885c028a8e6500b6d/backend/parsers/windmill-parser-py-imports/src/lib.rs#L48)

## Pinning dependencies and Requirements

If the imports are not properly analyzed, there exists an escape hatch to
override the inferred imports. One needs to head the Script with the following comment:

```python
#requirements:
#dependency
#version_pinned_dependency==0.4

import dependency

def main(...):
  ...
```

To combine both the inference of Windmill and being able to pin dependencies, use `extra_requirements`:

```python
#extra_requirements:
#dependency==0.4

import pandas
import dependency

def main(...):
  ...
```

### Private PyPi repository

In addition to that, environment variables can be set to customize `pip`'s index-url and extra-index-url and certificate.
This is useful for private repositories.

In a docker-compose file, you would add following lines:

```dockerfile
windmill_worker:
  ...
  environment:
    ...
    - PIP_INDEX_URL=https://pypi.org/simple
    - PIP_EXTRA_INDEX_URL=https://pypi.org/simple
    - PIP_TRUSTED_HOST=pypi.org
    - PIP_INDEX_CERT=/custom-certs/root-ca.crt
```

## Imports in Go

For Go, the dependencies and their versions are contained in the
script and hence there is no need for any additional steps.

e.g:

```go
import (
	"rsc.io/quote"
    wmill "github.com/windmill-labs/windmill-go-client"
)
```

## Imports in PowerShell

For PowerShell, imports are parsed when the script is run and modules are automatically installed if they are not found in the cache.

e.g.:

```powershell
Import-Module -Name MyModule
```

## Dependencies on Local Development

When created and edited through the UI (Windmill App), the lockfile is automatically generated. On [local development](../4_local_development/index.mdx), each script gets:
- a content file (`script_path.py`, `script_path.ts`, `script_path.go`, etc.) that contains the code of the script,
- a metadata file (`script_path.yaml`) that contains the metadata of the script,
- a lockfile (`script_path.lock`) that contains the dependencies of the script.

You can get those 3 files for each script by pulling your workspace with command [`wmill sync pull`](../3_cli/sync.mdx).

Editing a script is as simple as editing its content. The code can be edited freely in your IDE, and there are possibilities to even run it locally if you have the correct development environment setup for the script language.

Some fields of the metadata file can also be edited by hand, like the summary of the description fields. If you update the dependencies of your script, or the signature of the `main` method, the lockfile and/or the script schema will need to be updated. We do not recommend doing it by hand.

The lockfile is not meant to be edited manually. It is generated by Windmill when the script is created or edited through the UI and updated locally with the `wmill script generate-metadata` command. However, it is useful to check versions changes.

[Windmill CLI](../3_cli/index.mdx) comes with a `wmill script generate-metadata` command that will read all the files that have been edited and gracefully update the metadata file and lockfile accordingly.
This command is mainly used update the lockfile and schema inplace. Be re-assured, any manual update to other files like summary and description will be kept.

For each language, there is a way to pin the version directly within script (see [above](#pinning-dependencies-and-requirements)). This is the recommended way of managing dependencies and the authoritative way of handling dependencies via the UI.
Locally, the lockfile is respected. It "wins" over the dependencies pinned via the script. Hence the need of the `generate-metadata` command to update the lockfile and metadata files.

<div className="grid grid-cols-2 gap-6 mb-4">
	<DocCard
		title="Deploy to Prod using a Git Workflow"
		description="Windmill integration with Git repositories makes it possible to adopt a robust development process for your Windmill scripts, flows and apps."
		href="/docs/advanced/deploy_gh_gl"
	/>
	<DocCard
		title="Local Development"
		description="Develop locally, push to git and deploy automatically to Windmill."
		href="/docs/advanced/local_development"
	/>
</div>

## Relative Imports

To import other scripts from your workspace, see [Sharing common logic](../5_sharing_common_logic/index.md).

To import from a custom codebase, see [Codebases & Bundles](../../core_concepts/33_codebases_and_bundles/index.mdx).

<div className="grid grid-cols-2 gap-6 mb-4">
	<DocCard
		title="Sharing Common Logic"
		description="It is common to want to share common logic between your scripts. This can be done easily using relative imports in both Python and Deno."
		href="/docs/advanced/sharing_common_logic"
	/>
	<DocCard
		title="Codebases & Bundles"
		description="Deploy scripts with any local relative imports as bundles."
		href="/docs/core_concepts/codebases_and_bundles"
	/>
</div>