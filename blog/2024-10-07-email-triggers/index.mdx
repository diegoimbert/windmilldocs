---
slug: smtp-server
authors: [hugocasa]
tags: ['smtp', 'email', 'rust', 'tcp', 'tls']
description: 'In this article, we will implement a simple SMTP server in Rust to receive emails.'
image: ./smtp.webp
title: Implementing an SMTP server in Rust
---

# Implementing an SMTP server in Rust

In this article, we will implement a simple SMTP server in Rust to receive emails.
The code is a slightly modified version taken directly from the Windmill codebase, where it is used to trigger scripts and flows using emails. 

## What is SMTP

SMTP (Simple Mail Transfer Protocol) defines the protocol to transmit emails between clients and servers.

The global flow of an email from a sender to a recipient is the following: 
- The sender's client send the email to its SMTP server.
- The sender's SMTP server then checks for the recipient's email domain and sends the email to the recipient's SMTP server corresponding to the domain.

In the flow described above, there are two SMTP exchanges: sender_client \<-> sender_smtp \<-> recipient_smtp

Note: the recipient's SMTP server then stores the emails it receives and the client's retrieve them usually using POP or IMAP.

We will implement a SMTP server that will only be able to receive emails, not send them but the idea is the same.

First, our receiver SMTP server listens on a port for incoming TCP connections.
Once connected, the client (sender's SMTP server) sends commands to the receiver SMTP server.
Our server needs to understand a set of commands and respond correctly to them.
Once we get the email content, we can do whatever we want with it like processing it or storing it.
In the context of windmill, once we get the email, we check the email address and trigger the appropriate runnable with the email content as argument.

When SMTP servers communicate, they do so on port 25.
By default, they connect without encryption.
Therefore, we will also implement STARTTLS to be able to upgrade the connection to a secure TLS connection, making sure that the email content is encrypted in transit.

Note: Modern email clients connect to SMTP servers (e.g. when sending an email from your computer) on port 587 (or 465) directly over TLS.


## Listening for incoming connections

We use [tokio](https://tokio.rs/) to listen for TCP connections on port 2525 (in production, you need to expose it on port 25).
We handle each incoming connection in a separate task using `tokio::spawn` to avoid blocking the listener thread.

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader, BufWriter};
use std::net::SocketAddr;


async fn listen() -> anyhow::Result<()> {
    let addr = SocketAddr::from(([127, 0, 0, 1], 2525));
    let listener = TcpListener::bind(addr).await?;

    tracing::info!("SMTP server listening on {}", addr);

    loop {
        match listener.accept().await {
            Ok((stream, _)) => {
                tokio::spawn(async move {
                    if let Err(err) = handle_connection(stream).await {
                        tracing::error!("Error handling SMTP connection: {:?}", err);
                    };
                });
            }
            Err(err) => {
                tracing::error!("Error establishing SMTP connection: {:?}", err);
            }
        }
    }
}
```

Once we get the connection, we first need to send a `220 My SMTP server` response to the client:

```rust
async fn handle_connection(stream: &mut TcpStream) {
    let (reader, writer) = stream.split();
    let mut reader = BufReader::new(reader);
    let mut writer = BufWriter::new(writer);
    writer.write_all(b"220 My SMTP server\r\n").await?;
    writer.flush().await?;

    // handle session 
}
```

## The basic exchange loop

Once the sender (server or client) connects, it starts sending commands.
You can find the full list of possible commands here: https://datatracker.ietf.org/doc/html/rfc5321#section-4.

A simplified flow of commands could be:
- Sender: EHLO
- Receiver: 250 OK
- Sender: MAIL FROM: \<sender@mysenderdomain.com>
- Receiver: 250 OK
- Sender: RCPT TO: \<receiver@myreceiverdomain.com>
- Receiver: 250 OK
- Sender: DATA
- Receiver: 354 End data with \<CR>\<LF>.\<CR>\<LF>
- Sender: Subject: Test email
- Sender: Test email content
- Sender: .
- Receiver: 250 OK
- Sender: QUIT
- Receiver: 221 2.0.0 Bye

The sequence of commands is straightforward: the client begins with a greeting, specifies the sender and recipient, and then transmits the email content.
To transmit the email content, the client issues the DATA command. Everything sent after this command is considered part of the email content until a single dot `.` on a line by itself signals the end of the email.
Upon receiving the complete email, the receiver responds with a 250 OK if the email was successfully received.
Finally, the client sends the QUIT command to terminate the connection.

The following code implements the SMTP exchange.
It processes commands one by one, commands are separated by a line break `\r\n`.
At the start, the state is `SmtpState::Command`, we then process the command and depending on the command, we store the received data if any and update the state.
We have three states: 
- `SmtpState::Command`: The state after the connection is established and the client is waiting for a command.
- `SmtpState::Data`: The state after the DATA command has been received and the email content is being accumulated.
- `SmtpState::Quit`: The state after the QUIT command has been received, the connection is closed.

We use `Framed` with `LinesCodec` from the [tokio-util](https://crates.io/crates/tokio-util) crate to split the stream by lines.
We use regex to parse the sender and receiver addresses.

```rust
use tokio_util::codec::{Framed, LinesCodec, LinesCodecError};
use futures::{stream::iter, SinkExt, StreamExt};

async fn handle_session(mut stream: TcpStream) -> anyhow::Result<()> {
    let RE_SMTP_MAIL = regex::Regex::new(r"(?i)from: ?<(.+)>").unwrap();
    let RE_SMTP_RCPT = regex::Regex::new(r"(?i)to: ?<(.+)>").unwrap();
    let mut message = String::new();
    let mut state = SmtpState::Command;
    let mut mailfrom: Option<String> = None;
    let mut rcpts: Vec<String> = Vec::new();
    let mut framed = Framed::new(stream, LinesCodec::new());
    while let Some(line_str) = framed.next().await {
        let line = line_str?;
        match state {
            SmtpState::Command => {
                let space_pos = line.find(" ").unwrap_or(line.len());
                let (command, arg) = line.split_at(space_pos);
                let arg = arg.trim();
                match &*command.trim().to_uppercase() {
                    "HELO" | "EHLO" => {
                        send_commands(&mut framed, vec!["250 Hello".to_string()]).await?;
                    }
                    "MAIL" => {
                        // Handle MAIL FROM command
                        if let Some(address) = RE_SMTP_MAIL.captures(arg).and_then(|cap| cap.get(1)) {
                            mailfrom = Some(address.as_str().to_string());
                            send_commands(&mut framed, vec!["250 OK".to_string()]).await?;
                        } else {
                            send_commands(&mut framed, vec!["501 Syntax: MAIL From: <address>".to_string()]).await?;
                        }
                    }
                    "RCPT" => {
                        // Handle RCPT TO command
                        if mailfrom.is_none() {
                            send_commands(&mut framed, vec!["503 Error: Send MAIL first".to_string()]).await?   ;
                        } else {
                            if let Some(address) = RE_SMTP_RCPT.captures(arg).and_then(|cap| cap.get(1)) {
                                rcpts.push(address.as_str().to_string());
                                send_commands(&mut framed, vec!["250 OK".to_string()]).await?;
                            } else {
                                send_commands(&mut framed, vec!["501 Syntax: RCPT TO: <address>".to_string()]).await?;
                            }
                        }
                    }
                    "DATA" => {
                        if rcpts.is_empty() {
                            send_commands(&mut framed, vec!["503 Error: MAIL FROM and RCPT TO must be set before sending DATA".to_string()]).await?;
                        } else {
                            state = SmtpState::Data;
                            send_commands(&mut framed, vec!["354 End data with <CR><LF>.<CR><LF>".to_string()]).await?;
                        }
                    }
                    "NOOP" => {
                        send_commands(&mut framed, vec!["250 OK".to_string()]).await?   ;
                    }
                    "RSET" => {
                        mailfrom = None;
                        rcpts = Vec::new();
                        message = String::new();
                        send_commands(&mut framed, vec!["250 OK".to_string()]).await?;
                    }
                    "QUIT" => {
                        send_commands(&mut framed, vec!["221 Bye".to_string()]).await?;
                        state = SmtpState::Quit;
                    }
                    _ => {
                        send_commands(&mut framed, vec!["500 Unknown command".to_string()]).await?;
                    }
                }
            }
            SmtpState::Data => {
                if line.trim() == "." {
                    // The end of the email content has been received
                    send_commands(&mut framed, vec!["250 OK".to_string()]).await?;
                    // reset the state and variables for the next email
                    mailfrom = None;
                    rcpts = Vec::new();
                    message = String::new();
                    state = SmtpState::Command;
                    // we can now handle the email:
                    handle_email(mailfrom, rcpts, message);
                } else {
                    // Add the received line to the email content
                    message.push_str(&line);
                    message.push_str("\n");
                }
            }
            SmtpState::Quit => {
                break;
            }
        }
    }
}
```

The `send_commands` function is a helper to send a line of text to the client.

```rust
async fn send_commands(
    framed: &mut Framed<TlsStream<TcpStream>, LinesCodec>,
    commands: Vec<String>,
) -> anyhow::Result<()> {
    // only need to add \r because the codec only adds \n
    let messages = iter(commands.into_iter().map(|x| format!("{}\r", x)));
    framed.send_all(&mut messages.map(Ok)).await?;
    Ok(())
}
```

## STARTTLS

As explained above, to secure the communication between SMTP servers, we should use [STARTTLS](https://www.ietf.org/rfc/rfc3207.txt).
This protocol allows to upgrade an existing insecure connection to a TLS connection.

The flow starts the same way as before but the server specifies that it supports TLS by sending the `250-STARTTLS` response to the `EHLO` command.
The client, seeing that the server supports STARTTLS, sends the `STARTTLS` command.
The server responds with `220 GO ON` and then both the client and server perform the TLS handshake.
Once the handshake is complete, the usual SMTP exchange can take place on this TLS encrypted connection.
As we only want to receive emails when the connection is encrypted, we will not accept any of the `MAIL`, `RCPT` or `DATA` commands before the handshake is complete and we switch to the loop from `handle_session`.

```rust
async fn handle_unsecured_session(
    reader: &mut BufReader<TcpStream>,
    writer: &mut BufWriter<TcpStream>,
) -> anyhow::Result<()> {
    let mut is_tls = false;
    let mut line = String::new();
    while reader.read_line(&mut line).await? != 0 {
        let space_pos = line.find(" ").unwrap_or(line.len());
        let (command, _) = line.split_at(space_pos);

        match command.trim().to_uppercase().as_ref() {
            "EHLO" | "HELO" => {
                writer.write_all(b"250-windmill Hello\r\n").await?;
                writer.write_all(b"250-STARTTLS\r\n").await?;
                writer.write_all(b"250 What you've got?\r\n").await?;
                writer.flush().await?;
            }
            "STARTTLS" => {
                writer.write_all(b"220 GO ON\r\n").await?;
                writer.flush().await?;
                is_tls = true;
                break;
            }
            "QUIT" => {
                writer.write_all(b"221 Have a nice day!\r\n").await?;
                writer.flush().await?;
                break;
            }
            "NOOP" => {
                writer.write_all(b"250 OK\r\n").await?;
                writer.flush().await?;
            }
            "MAIL" | "RCPT" | "DATA" | "RSET" => {
                writer
                    .write_all(b"530 Must issue a STARTTLS command first\r\n")
                    .await?;
                writer.flush().await?;
            }
            _ => {
                writer.write_all(b"500 Unknown command\r\n").await?;
                writer.flush().await?;
            }
        }

        line.clear();
    }

    if is_tls {
        handle_starttls(stream).await?;
    }
}
```

The `handle_starttls` function is used to handle the TLS handshake. We use the [native-tls](https://crates.io/crates/native-tls) crate along with [tokio-native-tls](https://crates.io/crates/tokio-native-tls) for that.
You will need a certificate for the handshake, depending on your use case you will either use a self-signed certificate or a certificate from a trusted provider.

```rust
use native_tls::{Identity, TlsAcceptor};
use tokio_native_tls::{TlsAcceptor as TokioTlsAcceptor, TlsStream};

async fn handle_starttls(
    stream: &mut TcpStream,
) -> anyhow::Result<()> {
    // ideally the certificate should only be loaded from here and not generated each time
    let (pem_certificate, pem_private_key) = generate_certificate()?;
    let identity = Identity::from_pkcs8(&pem_certificate, &pem_private_key)?;
    let tls_acceptor = TlsAcceptor::builder(identity).build()?;
    let tls_acceptor = TokioTlsAcceptor::from(tls_acceptor);

    match tls_acceptor.accept(stream).await {
        Ok(stream) => {
            // we can now handle the normal SMTP session
            handle_session(stream).await?;
        }
        Err(e) => {
            tracing::error!("Error establishing SMTP TLS connection: {:?}", e);
        }
    }; 
}
```

Here's the code to generate a self-signed certificate using the [openssl](https://crates.io/crates/openssl) crate:

```rust
use openssl::{
    asn1::Asn1Time,
    pkey::PKey,
    rsa::Rsa,
    x509::{
        extension::{AuthorityKeyIdentifier, BasicConstraints, SubjectKeyIdentifier},
        X509NameBuilder, X509,
    },
};
fn generate_certificate() -> anyhow::Result<(String, String)> {
    let cert_result = {
        let rsa = Rsa::generate(4096)?;
        let pkey = PKey::from_rsa(rsa)?;
        let mut name = X509NameBuilder::new()?;
        name.append_entry_by_text("CN", "localhost")?;
        let name = name.build();
        let mut builder = X509::builder()?;
        builder.set_version(2)?;
        builder.set_subject_name(&name)?;
        builder.set_issuer_name(&name)?;
        builder.set_pubkey(&pkey)?;
        let now = Asn1Time::days_from_now(0)?;
        let later = Asn1Time::days_from_now(3650)?;
        builder.set_not_before(now.as_ref())?;
        builder.set_not_after(later.as_ref())?;
        builder.append_extension(BasicConstraints::new().critical().ca().build()?)?;
        builder.append_extension(SubjectKeyIdentifier::new().build(&builder.x509v3_context(None, None))?)?;
        builder.append_extension(AuthorityKeyIdentifier::new().keyid(true).issuer(true).build(&builder.x509v3_context(None, None))?)?;
        builder.sign(&pkey, openssl::hash::MessageDigest::sha256())?;
        let c = builder.build();
        Ok((c.to_pem()?, pkey.private_key_to_pem_pkcs8()?))
    }
    let (pem_certificate, pem_private_key) = cert_result
        .as_ref()
        .map_err(|e| anyhow::anyhow!("Could not generate self-signed certificates: {}", e))?;

    Ok((pem_certificate, pem_private_key))
}
```


## Testing

You can test that your server works by using `nc`:

```bash
nc localhost 2525
```

You should see the `220 My SMTP server` response.
You can then send commands to your server and see the responses.
You can't upgrade to TLS from nc, so sending the STARTTLS command from nc won't work.

You can however test the TLS handshake and be able to send emails using `openssl`:

```bash
openssl s_client -starttls smtp -connect localhost:2525
```

It will connect to the server, send `STARTTLS` and upgrade the connection to TLS.
You can then send commands to the server and send emails.

The command line is great for testing but it's more practicial to use a python script. 
Here's a simple example using the `smtplib` library:

```python
smtp_server = "localhost"
smtp_port = 2525
from_email = "you@example.com"
to_email = "to@example.com"
subject = "Test Email"
body = "This is a test email sent to my local SMTP server on port 2525."
html_body = "<html><body>This is a HTML</body></html>"

# Create the email
message = MIMEMultipart()
message["From"] = from_email
message["To"] = to_email
message["Subject"] = subject

message.attach(MIMEText(body, "plain"))
message.attach(MIMEText(html_body, "html"))

# to add an attachment:
# file_path = "myfile.txt"
# with open(file_path, "rb") as attachment:
#     part = MIMEBase("application", "octet-stream")
#     part.set_payload(attachment.read())
#     encoders.encode_base64(part)
#     part.add_header(
#         "Content-Disposition",
#         f"attachment; filename= {file_path}",
#     )
#     message.attach(part)

# Send the email
try:
    with smtplib.SMTP(smtp_server, smtp_port) as server:
        server.starttls()
        server.sendmail(from_email, to_email, message.as_string())
    print("Email sent successfully")
except Exception as e:
    print(f"Failed to send email: {e}")
```

## Deploying

You need to expose externally the server on port 25. You can use a reverse proxy to redirect the incoming SMTP connections to your server on port 2525.
For instance, we use [Caddy](https://caddyserver.com/) with a level 4 extension to support TCP proxying, our Dockerfile is available [here](https://github.com/windmill-labs/windmill/blob/main/docker/DockerfileCaddyL4), the image [here](https://github.com/windmill-labs/windmill/pkgs/container/caddy-l4) and the Caddyfile [here](https://github.com/windmill-labs/windmill/blob/main/Caddyfile).

You will also need to configure your DNS settings to point to your server.

You need two entries in your DNS settings:
- An A record that points to your server IP address (e.g. smtp.yourdomain.com)
- An MX record from the domain you want for your email addresses (e.g. yourdomain.com) to your server A record (e.g. smtp.yourdomain.com).

These settings will let the other SMTP servers know where to send the emails for your domain.

You can now test the server by sending an email from your private email address to an email address using the domain you configured in the DNS settings and checking that it is received by your SMTP server.

## Conclusion

In this article, we've implemented a simple SMTP server in Rust that can receive emails securely over TLS.
This could allow you to build your own mail server where you store the emails and access them over your own API.
You could also improve the SMTP server to be able to send emails, you can follow the same approach as the receiver but by sending the commands to the receiver SMTP server instead.

If you're interested in triggering scripts and flows using email, you can check out [Windmill](https://windmill.dev).
Windmill is an open-source platform and workflow engine for developers to execute jobs. 
It supports on-demand execution via an autogenerated UI or API calls, scheduling, event triggers (like email), and more.
We use a very similar code as above to allow triggering Windmill script or flows using email.

Thank you for reading! If you have any feedback or questions, feel free to contact us on our [Discord](https://discord.com/invite/V7PM2YHsPB).



